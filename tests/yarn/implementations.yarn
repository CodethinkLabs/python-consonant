Scenario test implementation
============================

Implementation section for making stores available
--------------------------------------------------

    IMPLEMENTS GIVEN a local standard test store "([a-zA-Z0-9-]+)"
    clone_test_schemas
    clone_test_store "$MATCH_1"

    IMPLEMENTS GIVEN a local Memcached instance
    memcached -d
    touch $DATADIR/use-memcached
    sleep 1

    IMPLEMENTS FINALLY stop the local Memcached instance
    skill -SIGKILL memcached
    sleep 1

Implementation section for using consonant.store
------------------------------------------------

Fetch a list of all Git refs from a local store.

    IMPLEMENTS WHEN listing Git refs using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.refs())
    EOF

Fetch a single ref from a local store.

    IMPLEMENTS WHEN fetching the ref "([a-zA-Z0-9:\-_/]+)" using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.ref('$MATCH_1'))
    EOF

    IMPLEMENTS WHEN fetching the non-existent ref "([a-zA-Z0-9:\-_/]+)" using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.ref('$MATCH_1'))
    EOF

Fetch a single commit from a local store.

    IMPLEMENTS WHEN fetching the commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.commit('$MATCH_1'))
    EOF

    IMPLEMENTS WHEN fetching the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.commit('$MATCH_1'))
    EOF

Obtain the store name from a commit in a local store.

    IMPLEMENTS WHEN obtaining the store name from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print store.name(store.commit('$MATCH_1'))
    EOF

    IMPLEMENTS WHEN obtaining the store name from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print store.name(store.commit('$MATCH_1'))
    EOF

Obtain service aliases from a commit in a local store.

    IMPLEMENTS WHEN obtaining service aliases from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print store.services(store.commit('$MATCH_1'))
    EOF

    IMPLEMENTS WHEN obtaining service aliases from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print store.services(store.commit('$MATCH_1'))
    EOF

Obtain the schema name from a commit in a local store.

    IMPLEMENTS WHEN obtaining the schema name from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print store.schema(store.commit('$MATCH_1'))
    EOF

    IMPLEMENTS WHEN obtaining the schema name from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print store.schema(store.commit('$MATCH_1'))
    EOF

Obain the classes from a commit in a local store.

    IMPLEMENTS WHEN obtaining the classes from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.classes(store.commit('$MATCH_1')))
    EOF

    IMPLEMENTS WHEN obtaining the classes from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.classes(store.commit('$MATCH_1')))
    EOF

Fetch objects from a commit in a local store.

    IMPLEMENTS WHEN fetching objects from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.objects(store.commit('$MATCH_1')))
    EOF

    IMPLEMENTS WHEN fetching objects from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.objects(store.commit('$MATCH_1')))
    EOF

    IMPLEMENTS WHEN fetching objects of class "(.+)" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    commit = store.commit('$MATCH_2')
    klass = store.klass(commit, '$MATCH_1')
    print yaml.dump(list(store.objects(commit, klass)))
    EOF

    IMPLEMENTS WHEN fetching objects of non-existent class "(.+)" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    commit = store.commit('$MATCH_2')
    klass = store.klass(commit, '$MATCH_1')
    print yaml.dump(list(store.objects(commit, klass)))
    EOF

    IMPLEMENTS WHEN fetching objects of class "(.+)" from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    commit = store.commit('$MATCH_2')
    klass = store.klass(commit, '$MATCH_1')
    print yaml.dump(list(store.objects(commit, klass)))
    EOF

    IMPLEMENTS WHEN fetching the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    print yaml.dump(store.object(store.commit('$MATCH_2'), '$MATCH_1'))
    EOF

    IMPLEMENTS WHEN fetching the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" of class "(.+)" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF
    commit = store.commit('$MATCH_3')
    klass = store.klass(commit, '$MATCH_2')
    print yaml.dump(store.object(commit, '$MATCH_1', klass))
    EOF

    IMPLEMENTS WHEN fetching the non-existent object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.object(store.commit('$MATCH_2'), '$MATCH_1'))
    EOF

    IMPLEMENTS WHEN fetching the non-existent object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" of class "(.+)" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    commit = store.commit('$MATCH_3')
    klass = store.klass(commit, '$MATCH_2')
    print yaml.dump(store.object(commit, '$MATCH_1', klass))
    EOF

    IMPLEMENTS WHEN fetching the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    print yaml.dump(store.object(store.commit('$MATCH_2'), '$MATCH_1'))
    EOF

    IMPLEMENTS WHEN fetching the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" of class "(.+)" from the non-existent commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    commit = store.commit('$MATCH_3')
    klass = store.klass(commit, '$MATCH_2')
    print yaml.dump(store.object(commit, '$MATCH_1', klass))
    EOF

    IMPLEMENTS WHEN fetching the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" of the wrong class "(.+)" from commit ([abcdefABCDEF0-9]+) using consonant.store
    run_python_with_store <<-EOF || true
    commit = store.commit('$MATCH_3')
    klass = store.klass(commit, '$MATCH_2')
    print yaml.dump(store.object(commit, '$MATCH_1', klass))
    EOF

Implementation section for checking the output of commands
----------------------------------------------------------

Check whether a specific local/remote branch or a tag is included in a
list of refs.

    IMPLEMENTS THEN the refs include a (local|remote) branch called "(.+)"
    run_python_test <<-EOF
    if '$MATCH_1' == 'local':
        if '$MATCH_2' == 'HEAD':
            assert 'HEAD' in output_yaml
        else:
            assert 'refs/heads/$MATCH_2' in output_yaml
    else:
        assert 'refs/remotes/%s' % '$MATCH_2' in output_yaml
    EOF

    IMPLEMENTS THEN the refs include a tag called "(.+)"
    run_python_test <<-EOF
    'refs/tags/$MATCH_1' in output_yaml
    EOF

Check whether a specific local/remote branch or a tag has a given URL
alias:

    IMPLEMENTS THEN the (local|remote) branch "(.+)" has an alias "(.+)"
    run_python_test <<-EOF
    if '$MATCH_1' == 'local':
        if '$MATCH_2' == 'HEAD':
            assert '$MATCH_3' in output_yaml['HEAD']['url-aliases']
        else:
            assert '$MATCH_3' in \
                output_yaml['refs/heads/$MATCH_2']['url-aliases']
    else:
        assert '$MATCH_3' in \
            output_yaml['refs/remotes/$MATCH_2']['url-aliases']
    EOF

    IMPLEMENTS THEN the tag "(.+)" has an alias "(.+)"
    run_python_test <<-EOF
    assert '$MATCH_2' in output_yaml['refs/tags/$MATCH_1']['url-aliases']
    EOF

Check whether a field in the output dictionary is present or not.

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is present
    run_python_test <<-EOF
    assert '$MATCH_1' in output_yaml
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" is present
    run_python_test <<-EOF
    object = [x for x in output_yaml if x['uuid'] == '$MATCH_2'][0]
    assert '$MATCH_1' in object
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is not present
    run_python_test <<-EOF
    assert '$MATCH_1' not in output_yaml
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" is present
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert '$MATCH_1' in object
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" is set to (.+)
    run_python_test <<-EOF
    object = [x for x in output_yaml if x['uuid'] == '$MATCH_2'][0]
    assert object['$MATCH_1'] == eval('$MATCH_3')
    EOF

Check whether a field in the output dictionary is set to a specific
value.

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is set to (.+)
    run_python_test <<-EOF
    assert output_yaml['$MATCH_1'] == eval('$MATCH_2')
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" > "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is set to (.+)
    run_python_test <<-EOF
    assert output_yaml['$MATCH_1']['$MATCH_2'] == eval('$MATCH_3')
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" is set to (.+)
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert object['$MATCH_1'] == eval('$MATCH_4')
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" is set to (.+)
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert object['properties']['$MATCH_1'] == eval('$MATCH_4')
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" is set to (.+)
    run_python_test <<-EOF
    object = [x for x in output_yaml if x['uuid'] == '$MATCH_2'][0]
    assert object['properties']['$MATCH_1'] == eval('$MATCH_3')
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is set to (.+)
    run_python_test <<-EOF
    assert output_yaml['properties']['$MATCH_1'] == eval('$MATCH_2')
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" > "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" includes the reference "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    assert {'uuid': '$MATCH_3'} in output_yaml['$MATCH_1']['$MATCH_2']
    EOF

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" > "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" does not include the reference "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    assert {'uuid': '$MATCH_3'} not in output_yaml['$MATCH_1']['$MATCH_2']
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" includes the reference "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert {'uuid': '$MATCH_4'} in object['properties']['$MATCH_1']
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" includes the reference "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    object = [x for x in output_yaml if x['uuid'] == '$MATCH_2'][0]
    assert {'uuid': '$MATCH_3'} in object['properties']['$MATCH_1']
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" references "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert object['properties']['$MATCH_1'] == {'uuid': '$MATCH_4'}
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" includes the reference "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    assert {'uuid': '$MATCH_2'} in output_yaml['properties']['$MATCH_1']
    EOF

    IMPLEMENTS THEN the property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" references "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    assert output_yaml['properties']['$MATCH_1'] == {'uuid': '$MATCH_2'}
    EOF

Check whether a field in the output dictionary includes a specific
object (not just a reference).

    IMPLEMENTS THEN the field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" includes the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    def object_matches_uuid(obj):
        return obj['uuid'] == '$MATCH_2'
    assert any([object_matches_uuid(x) for x in output_yaml['$MATCH_1']])
    EOF

Check whether a field in the output dictionary has a specific
size/length.

    IMPLEMENTS THEN the size of field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is ([0-9]+)
    run_python_test <<-EOF
    assert len(output_yaml['$MATCH_1']) == $MATCH_2
    EOF

    IMPLEMENTS THEN the size of field "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" > "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is ([0-9]+)
    run_python_test <<-EOF
    assert len(output_yaml['$MATCH_1']['$MATCH_2']) == $MATCH_3
    EOF

    IMPLEMENTS THEN the size of property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" in "(.+)" is ([0-9]+)
    run_python_test <<-EOF
    objects = output_yaml['$MATCH_3']
    object = [x for x in objects if x['uuid'] == '$MATCH_2'][0]
    assert len(object['properties']['$MATCH_1']) == $MATCH_4
    EOF

    IMPLEMENTS THEN the size of property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" of object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])" is ([0-9]+)
    run_python_test <<-EOF
    object = [x for x in output_yaml if x['uuid'] == '$MATCH_2'][0]
    assert len(object['properties']['$MATCH_1']) == $MATCH_3
    EOF

    IMPLEMENTS THEN the size of property "([a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])" is ([0-9]+)
    run_python_test <<-EOF
    assert len(output_yaml['properties']['$MATCH_1']) == $MATCH_2
    EOF

Check whether a given exception is thrown.

    IMPLEMENTS THEN an? (.+) is thrown
    test_for_exception "$MATCH_1"

Check whether the result is set to a given value.

    IMPLEMENTS THEN the result is "(.+)"
    test "$(cat $DATADIR/stdout | xargs echo -n)" = "$MATCH_1"

Check whether the result is an empty mapping.

    IMPLEMENTS THEN the result is an empty mapping
    run_python_test <<-EOF
    assert output_yaml == {}
    EOF

Check whether the result is a set with a specific size/length.

    IMPLEMENTS THEN the result is a list of size ([0-9]+)
    run_python_test <<-EOF
    assert isinstance(output_yaml, list)
    assert len(output_yaml) == $MATCH_1
    EOF

Check whether the result set or list includes a given object.

    IMPLEMENTS THEN the result includes the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    def object_matches_uuid(obj):
        return obj['uuid'] == '$MATCH_1'
    assert any([object_matches_uuid(x) for x in output_yaml])
    EOF

Check whether a mapping of service aliases includes a given alias.

    IMPLEMENTS THEN the service aliases include "(.+)"
    run_python_test <<-EOF
    assert '$MATCH_1' in output_yaml
    EOF

Check whether a mapping of service aliases does not include a given
alias.

    IMPLEMENTS THEN the service aliases do not include "(.+)"
    run_python_test <<-EOF
    assert '$MATCH_1' not in output_yaml
    EOF

Check whether a memcached item holds an object with a specific UUID.

    IMPLEMENTS THEN the memcached item ([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9],[abcdef0-9]{40}) holds the object "([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])"
    run_python_test <<-EOF
    import pylibmc
    mc = pylibmc.Client(['127.0.0.1'])
    object = mc.get('$MATCH_1')
    assert object.uuid == '$MATCH_2'
    EOF

Check whether memcached has processed a specific number of get or set
commands.

    IMPLEMENTS THEN memcached has processed ([0-9]+) (get|set) commands
    run_python_test <<-EOF
    import pylibmc
    mc = pylibmc.Client(['127.0.0.1'])
    stats = mc.get_stats()
    assert stats[0][1]['cmd_$MATCH_2'] == str($MATCH_1), stats
    EOF

Check whether memcached holds a specific number of items.

    IMPLEMENTS THEN memcached holds ([0-9]+) items
    run_python_test <<-EOF
    import pylibmc
    mc = pylibmc.Client(['127.0.0.1'])
    stats = mc.get_stats()
    assert stats[0][1]['curr_items'] == str($MATCH_1), stats
    EOF

Check whether memcached has a specific amount of hits or misses.

    IMPLEMENTS THEN memcached has ([0-9]+) (hits|misses)
    run_python_test <<-EOF
    import pylibmc
    mc = pylibmc.Client(['127.0.0.1'])
    stats = mc.get_stats()
    assert stats[0][1]['get_$MATCH_2'] == str($MATCH_1), stats
    EOF
